# 🗃️ EfCoreTest

A test project to easily demonstrate the usage of `exec sp_executesql` from Entity Framework Core.

## 🎯 Purpose

This project shows how EF Core generates and executes parameterized SQL queries using `sp_executesql`. By running SQL Server Profiler while the application executes various LINQ queries, you can observe the actual T-SQL statements being sent to the database.

## ✅ Prerequisites

- 🔷 .NET 10 SDK
- 📊 SQL Server Profiler (included with SQL Server Management Studio)
- 🐳 Docker (for running SQL Server via Aspire)

## 🚀 How to Use

### 1️⃣ Run the Aspire AppHost

Start the application using the Aspire AppHost:

```bash
cd src/EfCoreTest/AppHost
dotnet run
```

This will:
- Start a SQL Server container on port 5432
- Create a test database with sample data (50,000 products, 10,000 orders, ~50,000 order items)
- Execute several LINQ queries that demonstrate different SQL patterns

### 2️⃣ Start SQL Server Profiler

1. Open **SQL Server Profiler** (comes with SQL Server Management Studio)
2. Import the provided profile template:
   - Go to **File** > **Import** > **Trace Template...**
   - Select `SelectsOnly.tdf` from the `src/EfCoreTest` directory
2. Connect to the SQL Server instance:
   - **Server**: `localhost,5432`
   - **Authentication**: SQL Server Authentication
   - **Login**: `sa`
   - **Password**: `Sup3rS3cret!`
3. Start a new trace to capture SQL statements using the imported template

### 3️⃣ Execute the Application

1. Click the Play-icon of the EfCoreTest resource in the Aspire Dashboard
2. Observe the console output and wait for it to finish

### 4️⃣ Observe the Profiler

In SQL Server Profiler, you'll see the `exec sp_executesql` calls generated by EF Core for queries like:

- **Query 1**: Simple filtered query with `WHERE` clause
  ```csharp
  await db.Products
    .Where(p => p.IsActive && p.Price > maxPrice)
    .Select(p => new { p.Id, p.Name, p.Price, p.StockQuantity })
    .OrderByDescending(p => p.Price)
    .ToListAsync();
  ```

  ```sql
  exec sp_executesql N'SELECT [p].[Id], [p].[Name], [p].[Price], [p].[StockQuantity]
  FROM [Products] AS [p]
  WHERE [p].[IsActive] = CAST(1 AS bit) AND [p].[Price] > @p
  ORDER BY [p].[Price] DESC',N'@p decimal(18,2)',@p=500.00
  ```

- **Query 2**: Subquery with `ANY` (existence check)
  ```csharp
  await db.Orders
    .Where(o => o.OrderItems.Any(oi => oi.ProductId == productId))
    .Select(o => new { o.Id, o.CustomerName, o.OrderDate, o.TotalAmount })
    .Skip(100)
    .Take(100)
    .ToListAsync();
  ```

  ```sql
    exec sp_executesql N'SELECT [o].[Id], [o].[CustomerName], [o].[OrderDate], [o].[TotalAmount]
    FROM [Orders] AS [o]
    WHERE EXISTS (
        SELECT 1
        FROM [OrderItems] AS [o0]
        WHERE [o].[Id] = [o0].[OrderId] AND [o0].[ProductId] = @p)
    ORDER BY (SELECT 1)
    OFFSET @p0 ROWS FETCH NEXT @p0 ROWS ONLY',N'@p bigint,@p0 int',@p=1,@p0=100
  ```
- **Query 3**: Aggregation with `GROUP BY` and `ORDER BY`
  ```csharp
  await db.OrderItems
    .GroupBy(oi => oi.Order.CustomerName)
    .Select(g => new { CustomerName = g.Key, TotalProductsOrdered = g.Sum(oi => oi.Quantity) })
    .OrderByDescending(x => x.TotalProductsOrdered)
    .ToListAsync();
  ```

  ```sql
    SELECT [o0].[CustomerName], COALESCE(SUM([o].[Quantity]), 0) AS [TotalProductsOrdered]
    FROM [OrderItems] AS [o]
    INNER JOIN [Orders] AS [o0] ON [o].[OrderId] = [o0].[Id]
    GROUP BY [o0].[CustomerName]
    ORDER BY COALESCE(SUM([o].[Quantity]), 0) DESC
  ```

### 5️⃣ Conclusion
EF Core 10 always uses `sp_executesql` for executing parameterized queries, which helps prevent SQL injection and allows SQL Server to cache execution plans effectively.
It uses normal SELECT statements for non-parameterized queries.

## 📁 Project Structure

| Project | Description |
|---------|-------------|
| `AppHost` | .NET Aspire host that orchestrates SQL Server and the test application |
| `EfCoreTest` | Console application with EF Core DbContext and sample queries |

## 📦 Data Model

- 🏷️ **Product**: Products with name, description, price, stock, SKU, and status
- 🛒 **Order**: Customer orders with shipping info and status
- 📋 **OrderItem**: Line items linking orders to products with quantity and pricing
